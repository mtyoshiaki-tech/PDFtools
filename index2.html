<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="robots" content="noindex"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Tools - Secure Local Processing</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Icons (Lucide) -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- PDF Libraries -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/downloadjs@1.4.7/download.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <!-- PDF.js for rendering previews -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b; 
        }
        ::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; 
        }

        .drop-zone {
            transition: all 0.2s ease;
            border: 3px dashed #334155;
            background-color: #1e293b;
        }
        .drop-zone:hover, .drop-zone.active {
            border-color: #3b82f6;
            background-color: #1e293b;
        }

        /* Loading Spinner */
        .loader {
            border: 4px solid #334155;
            border-radius: 50%;
            border-top: 4px solid #3b82f6;
            width: 28px;
            height: 28px;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .page-thumbnail {
            transition: all 0.2s;
        }
        .page-thumbnail:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.3);
        }
        .page-thumbnail.selected {
            opacity: 0.5;
            filter: grayscale(100%);
            position: relative;
        }
        .page-thumbnail.selected::after {
            content: '削除';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ef4444;
            color: white;
            padding: 6px 16px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: bold;
            z-index: 10;
        }
        
        /* Split specific styles */
        .split-thumbnail {
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
        }
        .split-thumbnail.split-point {
            margin-right: 20px; /* Space for the scissor */
        }
        .split-thumbnail.split-point::after {
            content: '';
            position: absolute;
            right: -18px;
            top: 0;
            bottom: 0;
            width: 4px;
            background: #3b82f6;
            z-index: 20;
        }
        .split-part-1 {
            border: 4px solid #3b82f6;
        }
        .split-part-2 {
            border: 4px solid #10b981;
            opacity: 0.8;
        }

        /* Drag and Drop Styles */
        .draggable-item {
            cursor: grab;
        }
        .draggable-item.dragging {
            opacity: 0.5;
            border: 2px dashed #3b82f6;
            background: #1e293b;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col text-base">

    <!-- Navbar -->
    <nav class="bg-slate-800 border-b border-slate-700 sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-6">
            <div class="flex items-center justify-between h-20">
                <div class="flex items-center gap-3 cursor-pointer" onclick="switchTab('compress')">
                    <div class="bg-blue-600 text-white p-2 rounded-lg">
                        <i data-lucide="file-text" class="w-6 h-6"></i>
                    </div>
                    <span class="font-bold text-xl tracking-tight text-white">PDF Tools</span>
                </div>
                <div class="hidden md:flex space-x-2">
                    <button onclick="switchTab('compress')" class="nav-btn px-4 py-3 rounded-lg text-base font-medium text-slate-300 hover:bg-slate-700 hover:text-white transition-colors" data-tab="compress">圧縮</button>
                    <button onclick="switchTab('split')" class="nav-btn px-4 py-3 rounded-lg text-base font-medium text-slate-300 hover:bg-slate-700 hover:text-white transition-colors" data-tab="split">分割</button>
                    <button onclick="switchTab('merge')" class="nav-btn px-4 py-3 rounded-lg text-base font-medium text-slate-300 hover:bg-slate-700 hover:text-white transition-colors" data-tab="merge">結合</button>
                    <button onclick="switchTab('organize')" class="nav-btn px-4 py-3 rounded-lg text-base font-medium text-slate-300 hover:bg-slate-700 hover:text-white transition-colors" data-tab="organize">整理</button>
                    <button onclick="switchTab('convert')" class="nav-btn px-4 py-3 rounded-lg text-base font-medium text-slate-300 hover:bg-slate-700 hover:text-white transition-colors" data-tab="convert">変換</button>
                    <button onclick="switchTab('number')" class="nav-btn px-4 py-3 rounded-lg text-base font-medium text-slate-300 hover:bg-slate-700 hover:text-white transition-colors" data-tab="number">番号</button>
                </div>
            </div>
        </div>
        <!-- Mobile Menu -->
        <div class="md:hidden flex overflow-x-auto pb-3 px-4 gap-3 no-scrollbar">
            <button onclick="switchTab('compress')" class="nav-btn whitespace-nowrap px-4 py-2 rounded-full text-base font-medium border border-slate-700 text-slate-300" data-tab="compress">圧縮</button>
            <button onclick="switchTab('split')" class="nav-btn whitespace-nowrap px-4 py-2 rounded-full text-base font-medium border border-slate-700 text-slate-300" data-tab="split">分割</button>
            <button onclick="switchTab('merge')" class="nav-btn whitespace-nowrap px-4 py-2 rounded-full text-base font-medium border border-slate-700 text-slate-300" data-tab="merge">結合</button>
            <button onclick="switchTab('organize')" class="nav-btn whitespace-nowrap px-4 py-2 rounded-full text-base font-medium border border-slate-700 text-slate-300" data-tab="organize">整理</button>
            <button onclick="switchTab('convert')" class="nav-btn whitespace-nowrap px-4 py-2 rounded-full text-base font-medium border border-slate-700 text-slate-300" data-tab="convert">変換</button>
            <button onclick="switchTab('number')" class="nav-btn whitespace-nowrap px-4 py-2 rounded-full text-base font-medium border border-slate-700 text-slate-300" data-tab="number">番号</button>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="flex-grow max-w-5xl mx-auto w-full px-6 py-10">
        
        <!-- Header Section -->
        <div class="text-center mb-12">
            <div class="inline-flex items-center gap-2 px-4 py-1.5 rounded-full bg-slate-800 text-green-400 text-sm font-medium border border-slate-700 mb-6">
                <i data-lucide="shield-check" class="w-4 h-4"></i>
                Secure Local Processing
            </div>
            <h1 id="page-title" class="text-4xl font-bold text-white mb-4">PDFを圧縮</h1>
            <p id="page-desc" class="text-lg text-slate-400 max-w-2xl mx-auto">ブラウザ上で安全にPDFを処理します。ファイルはサーバーに送信されません。</p>
        </div>

        <!-- Dynamic Content Area -->
        <div id="app-container" class="bg-slate-800 rounded-3xl shadow-xl border border-slate-700 overflow-hidden min-h-[450px]">
            <!-- Content injected via JS -->
        </div>

    </main>

    <!-- Footer -->
    <footer class="border-t border-slate-800 bg-slate-900 py-8 mt-auto">
        <div class="max-w-7xl mx-auto px-6 text-center text-slate-500 text-base">
            <p>© 2026 PDF Tools. Secure Local Processing.</p>
        </div>
    </footer>

    <!-- Templates -->
    <script>
        const { PDFDocument, rgb, StandardFonts, degrees } = PDFLib;

        // --- State Management (Per Tab) ---
        const appState = {
            currentTab: 'compress', 
            
            compress: {
                files: [],
                isProcessing: false
            },
            split: {
                files: [],
                pdfDoc: null, 
                splitPoint: 0,
                visualsGenerated: false
            },
            merge: {
                files: []
            },
            organize: {
                files: [],
                pdfDoc: null,
                pageStates: [], 
                visualsGenerated: false
            },
            convert: {
                mode: 'img2pdf',
                images: [],     
                pdfFiles: []    
            },
            number: {
                files: []
            }
        };

        // --- UI Rendering Functions ---

        function renderTabs() {
            document.querySelectorAll('.nav-btn').forEach(btn => {
                if(btn.dataset.tab === appState.currentTab) {
                    btn.classList.add('bg-blue-900/40', 'text-blue-400', 'border-blue-700');
                    btn.classList.remove('text-slate-300', 'border-slate-700', 'hover:bg-slate-700');
                } else {
                    btn.classList.remove('bg-blue-900/40', 'text-blue-400', 'border-blue-700');
                    btn.classList.add('text-slate-300', 'border-slate-700', 'hover:bg-slate-700');
                }
            });

            const titles = {
                compress: ['PDFを圧縮', 'PDFの容量を約3MB程度を目安に圧縮します。選択すると自動で処理が始まります。'],
                split: ['PDFを分割', 'ページ範囲を指定して分割、または全ページを個別に保存します。'],
                merge: ['PDFを結合', '複数のPDFファイルを一つのファイルに結合します。'],
                organize: ['ページの整理', '不要なページを削除したり、プレビューを確認できます。'],
                convert: ['フォーマット変換', '画像をPDFに、またはPDFを画像に変換します。'],
                number: ['ページ番号を追加', 'PDFにページ番号を追記します。']
            };
            
            document.getElementById('page-title').textContent = titles[appState.currentTab][0];
            document.getElementById('page-desc').textContent = titles[appState.currentTab][1];
        }

        function switchTab(tab) {
            appState.currentTab = tab;
            renderTabs();
            renderContent();
        }

        function renderContent() {
            const container = document.getElementById('app-container');
            container.innerHTML = ''; 

            switch(appState.currentTab) {
                case 'compress':
                    container.innerHTML = getCompressTemplate();
                    break;
                case 'split':
                    container.innerHTML = getSplitTemplate();
                    if(appState.split.files.length > 0 && !appState.split.visualsGenerated) {
                        loadSplitPreview(appState.split.files[0]);
                    } else if (appState.split.visualsGenerated) {
                        loadSplitPreview(appState.split.files[0]); 
                    }
                    break;
                case 'merge':
                    container.innerHTML = getMergeTemplate();
                    setupMergeDragAndDrop(); 
                    break;
                case 'organize':
                    container.innerHTML = getOrganizeTemplate();
                    // Fix: Logic matches Split. Only load if not generated.
                    if(appState.organize.files.length > 0 && !appState.organize.visualsGenerated) {
                        loadOrganizePreview(appState.organize.files[0]);
                    } else if (appState.organize.visualsGenerated) {
                        loadOrganizePreview(appState.organize.files[0], true);
                    }
                    break;
                case 'convert':
                    container.innerHTML = getConvertTemplate();
                    break;
                case 'number':
                    container.innerHTML = getNumberTemplate();
                    break;
            }
            lucide.createIcons();
            setupDragAndDrop();
        }

        // --- Template Generators ---

        function getUploadBoxHTML(id, accept, text = "クリックしてファイルを選択", subtext = "") {
            return `
                <div class="p-10 flex items-center justify-center h-full">
                    <div id="${id}-drop" class="drop-zone w-full max-w-2xl rounded-2xl p-16 text-center cursor-pointer hover:bg-slate-700/50 relative group">
                        <input type="file" id="${id}-input" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10" accept="${accept}" ${id === 'merge-upload' || id === 'img' ? 'multiple' : ''}>
                        <div class="pointer-events-none relative z-0">
                            <div class="w-20 h-20 bg-slate-700 text-blue-400 rounded-full flex items-center justify-center mx-auto mb-6 group-hover:scale-110 transition-transform">
                                <i data-lucide="upload-cloud" class="w-10 h-10"></i>
                            </div>
                            <h3 class="text-2xl font-bold text-slate-200 mb-2">${text}</h3>
                            ${subtext ? `<p class="text-base text-slate-400">${subtext}</p>` : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        // --- COMPRESS TEMPLATE ---
        function getCompressTemplate() {
            if (appState.compress.isProcessing) {
                return `
                    <div class="flex flex-col items-center justify-center h-[450px] text-center p-8">
                        <div class="loader mb-6" style="width: 48px; height: 48px; border-width: 6px;"></div>
                        <h2 class="text-2xl font-bold text-slate-200 mb-2">圧縮処理中...</h2>
                        <p class="text-slate-400">ファイルを最適化しています。そのままお待ちください。</p>
                        <p class="text-xs text-slate-500 mt-4">※テキストは画像化される場合があります</p>
                    </div>
                `;
            }
            
            if (appState.compress.files.length === 0) {
                return getUploadBoxHTML('compress', '.pdf', "クリックしてファイルを選択", "アップロード後、自動的に圧縮・ダウンロードされます");
            }

            return getUploadBoxHTML('compress', '.pdf', "別のファイルを圧縮", "クリックして選択");
        }


        // --- SPLIT TEMPLATE ---
        function getSplitTemplate() {
            if (appState.split.files.length === 0) {
                return getUploadBoxHTML('split', '.pdf');
            }
            const file = appState.split.files[0];
            return `
                <div class="flex flex-col h-full">
                    <div class="p-6 border-b border-slate-700 flex justify-between items-center bg-slate-800">
                        <div class="flex items-center gap-3">
                            <div class="bg-red-900/30 text-red-400 p-2 rounded-lg"><i data-lucide="file" class="w-5 h-5"></i></div>
                            <div>
                                <p class="font-bold text-slate-200">${file.name}</p>
                            </div>
                        </div>
                        <div class="flex gap-2">
                             <button onclick="resetCurrentTab()" class="text-slate-400 hover:text-slate-200 px-4"><i data-lucide="rotate-ccw" class="w-6 h-6"></i></button>
                             <button onclick="processSplit('all')" class="bg-slate-700 text-slate-200 border border-slate-600 px-4 py-2 rounded-lg text-sm font-bold hover:bg-slate-600">
                                全ページ分割 (ZIP)
                            </button>
                            <button onclick="processSplit('specific')" class="bg-blue-600 text-white px-6 py-2 rounded-lg text-base font-bold hover:bg-blue-500 shadow-md">
                                分割して保存 (ZIP)
                            </button>
                        </div>
                    </div>
                    
                    <div class="p-4 bg-slate-800/50 text-center text-sm text-slate-400 border-b border-slate-700">
                        分割したい箇所のページをクリックしてください。クリックしたページの後ろで分割されます。
                    </div>

                    <div id="split-grid" class="p-8 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-x-8 gap-y-6 bg-slate-900 min-h-[400px]">
                        <div class="col-span-full text-center py-16 text-slate-500 flex items-center justify-center gap-3 text-lg">
                             <div class="loader"></div> 読み込み中...
                        </div>
                    </div>
                </div>
            `;
        }

        // --- MERGE TEMPLATE ---
        function getMergeTemplate() {
            const listHtml = appState.merge.files.map((file, idx) => `
                <div class="draggable-item flex items-center justify-between bg-slate-700 border border-slate-600 p-4 rounded-xl mb-3 group hover:border-blue-500 transition-colors" draggable="true" data-index="${idx}">
                    <div class="flex items-center gap-4 overflow-hidden pointer-events-none">
                        <div class="text-slate-400 group-hover:text-slate-200"><i data-lucide="grip-vertical" class="w-5 h-5"></i></div>
                        <div class="bg-red-900/30 text-red-400 p-2 rounded-lg"><i data-lucide="file" class="w-5 h-5"></i></div>
                        <span class="text-base font-medium text-slate-200 truncate">${file.name}</span>
                    </div>
                    <div class="flex items-center gap-2">
                         <button onclick="moveFileMerge(${idx}, -1)" class="p-2 hover:bg-slate-600 rounded-lg text-slate-400 hover:text-slate-200" ${idx === 0 ? 'disabled style="opacity:0.3"' : ''}><i data-lucide="arrow-up" class="w-5 h-5"></i></button>
                         <button onclick="moveFileMerge(${idx}, 1)" class="p-2 hover:bg-slate-600 rounded-lg text-slate-400 hover:text-slate-200" ${idx === appState.merge.files.length - 1 ? 'disabled style="opacity:0.3"' : ''}><i data-lucide="arrow-down" class="w-5 h-5"></i></button>
                         <button onclick="removeFileMerge(${idx})" class="p-2 hover:bg-red-900/50 rounded-lg text-slate-400 hover:text-red-400"><i data-lucide="trash-2" class="w-5 h-5"></i></button>
                    </div>
                </div>
            `).join('');

            return `
                <div class="flex flex-col h-full">
                    <div class="p-8 border-b border-slate-700 bg-slate-800">
                        <div id="merge-upload-drop" class="border-3 border-dashed border-slate-600 rounded-xl p-8 text-center hover:bg-slate-700/50 hover:border-blue-500 transition-colors cursor-pointer relative">
                             <input type="file" id="merge-upload-input" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10" accept=".pdf" multiple>
                             <div class="flex items-center justify-center gap-3 text-slate-400 relative z-0">
                                <i data-lucide="plus-circle" class="w-6 h-6"></i>
                                <span class="font-bold text-lg">ファイルを追加</span>
                             </div>
                        </div>
                    </div>
                    <div class="p-8 flex-grow" id="merge-list-container">
                        ${appState.merge.files.length > 0 ? listHtml : '<div class="text-center text-slate-500 py-12 text-lg">ファイルがありません</div>'}
                    </div>
                    ${appState.merge.files.length > 0 ? `
                        <div class="p-8 border-t border-slate-700 bg-slate-800">
                            <button onclick="processMerge()" class="w-full bg-blue-600 text-white py-4 rounded-xl text-lg font-bold hover:bg-blue-500 transition-colors shadow-lg shadow-blue-900/20 flex items-center justify-center gap-3">
                                <i data-lucide="merge" class="w-6 h-6"></i>
                                結合してダウンロード
                            </button>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // --- ORGANIZE TEMPLATE ---
        function getOrganizeTemplate() {
            if (appState.organize.files.length === 0) {
                return getUploadBoxHTML('organize', '.pdf');
            }
            
            return `
                <div class="flex flex-col h-full">
                    <div class="p-6 border-b border-slate-700 flex justify-between items-center bg-slate-800 sticky top-0 z-10">
                        <div class="flex items-center gap-3">
                            <button onclick="toggleAllOrganize(false)" class="text-sm px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg font-bold text-slate-300">全選択(残す)</button>
                            <button onclick="toggleAllOrganize(true)" class="text-sm px-4 py-2 bg-red-900/30 hover:bg-red-900/50 rounded-lg font-bold text-red-400">全削除</button>
                        </div>
                        <div class="flex gap-3">
                             <button onclick="resetCurrentTab()" class="text-slate-400 hover:text-slate-200 px-4"><i data-lucide="rotate-ccw" class="w-6 h-6"></i></button>
                            <button onclick="processOrganize()" class="bg-blue-600 text-white px-6 py-2 rounded-lg text-base font-bold hover:bg-blue-500 shadow-md">
                                保存する
                            </button>
                        </div>
                    </div>
                    <div id="organize-grid" class="p-8 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 bg-slate-900 min-h-[400px]">
                        <div class="col-span-full text-center py-16 text-slate-500 flex items-center justify-center gap-3 text-lg">
                             <div class="loader"></div> 読み込み中...
                        </div>
                    </div>
                </div>
            `;
        }

        // --- CONVERT TEMPLATE ---
        function getConvertTemplate() {
             const isImg2Pdf = appState.convert.mode === 'img2pdf';
             const isPdf2Img = appState.convert.mode === 'pdf2img';

             const activeTab = "border-b-2 border-blue-500 text-blue-400 bg-slate-800";
             const inactiveTab = "text-slate-400 hover:text-slate-200";

             return `
                <div>
                    <div class="flex border-b border-slate-700">
                        <button onclick="switchConvertMode('img2pdf')" class="flex-1 py-5 text-center font-bold text-lg ${isImg2Pdf ? activeTab : inactiveTab}">画像 → PDF</button>
                        <button onclick="switchConvertMode('pdf2img')" class="flex-1 py-5 text-center font-bold text-lg ${isPdf2Img ? activeTab : inactiveTab}">PDF → 画像</button>
                    </div>
                    
                    <!-- Img 2 PDF -->
                    <div class="p-8 ${isImg2Pdf ? '' : 'hidden'}">
                         ${appState.convert.images.length === 0 ? 
                            getUploadBoxHTML('img', 'image/png, image/jpeg', 'クリックしてファイルを選択', '(複数選択可)') : 
                            `
                            <div class="grid grid-cols-3 md:grid-cols-4 gap-4 mb-8">
                                ${appState.convert.images.map((img, idx) => `
                                    <div class="relative aspect-[3/4] bg-slate-700 rounded-xl overflow-hidden border border-slate-600 shadow-md">
                                        <img src="${img.url}" class="w-full h-full object-cover">
                                        <button onclick="removeImage(${idx})" class="absolute top-2 right-2 bg-red-500 text-white p-1.5 rounded-full hover:bg-red-600 shadow-sm"><i data-lucide="x" class="w-4 h-4"></i></button>
                                        <div class="absolute bottom-0 left-0 right-0 bg-black/70 text-white text-xs p-2 truncate font-medium">${img.file.name}</div>
                                    </div>
                                `).join('')}
                                <div class="aspect-[3/4] border-3 border-dashed border-slate-600 rounded-xl flex flex-col items-center justify-center text-slate-400 hover:bg-slate-700/50 hover:border-blue-500 cursor-pointer relative group">
                                    <input type="file" id="img-add-more" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10" accept="image/png, image/jpeg" multiple onchange="handleFileSelect(event, 'img2pdf')">
                                    <i data-lucide="plus" class="w-8 h-8 mb-2 relative z-0 group-hover:scale-110 transition-transform"></i>
                                    <span class="text-sm font-bold relative z-0">追加</span>
                                </div>
                            </div>
                            <button onclick="processImgToPdf()" class="w-full bg-blue-600 text-white py-4 rounded-xl text-lg font-bold hover:bg-blue-500 transition-colors shadow-lg shadow-blue-900/20">
                                PDFを作成
                            </button>
                            `
                        }
                    </div>

                    <!-- PDF 2 Img -->
                    <div class="p-8 ${isPdf2Img ? '' : 'hidden'}">
                         ${appState.convert.pdfFiles.length === 0 ? 
                            getUploadBoxHTML('pdf2img', '.pdf') :
                            `
                            <div class="flex items-center justify-between bg-slate-900 p-5 rounded-xl mb-8 border border-slate-700">
                                <div class="flex items-center gap-4">
                                    <div class="bg-red-900/30 text-red-400 p-3 rounded-lg"><i data-lucide="file" class="w-6 h-6"></i></div>
                                    <div>
                                        <p class="font-bold text-lg text-slate-200">${appState.convert.pdfFiles[0].name}</p>
                                    </div>
                                </div>
                                <button onclick="resetCurrentTab()" class="text-slate-400 hover:text-slate-200 p-2"><i data-lucide="x" class="w-6 h-6"></i></button>
                            </div>
                            <button onclick="processPdfToImg()" class="w-full bg-blue-600 text-white py-4 rounded-xl text-lg font-bold hover:bg-blue-500 transition-colors shadow-lg shadow-blue-900/20">
                                画像として保存 (ZIP)
                            </button>
                            `
                        }
                    </div>
                </div>
            `;
        }

        // --- NUMBER TEMPLATE ---
        function getNumberTemplate() {
            if (appState.number.files.length === 0) {
                return getUploadBoxHTML('number', '.pdf');
            }
            return `
                <div class="p-8">
                    <div class="flex items-center justify-between bg-slate-900 p-5 rounded-xl mb-8 border border-slate-700">
                         <div class="flex items-center gap-4">
                            <div class="bg-red-900/30 text-red-400 p-3 rounded-lg"><i data-lucide="file" class="w-6 h-6"></i></div>
                            <p class="font-bold text-lg text-slate-200">${appState.number.files[0].name}</p>
                        </div>
                        <button onclick="resetCurrentTab()" class="text-slate-400 hover:text-slate-200 p-2"><i data-lucide="x" class="w-6 h-6"></i></button>
                    </div>

                    <div class="grid md:grid-cols-2 gap-8 mb-8">
                        <div>
                            <label class="block text-base font-bold text-slate-300 mb-3">表示位置</label>
                            <div class="grid grid-cols-3 gap-3">
                                ${['tl', 'tc', 'tr', 'bl', 'bc', 'br'].map(pos => `
                                    <button onclick="setNumberPos('${pos}')" class="number-pos-btn border border-slate-600 rounded-xl p-4 hover:bg-slate-700 flex justify-center ${pos === 'bc' ? 'bg-blue-900/30 border-blue-500 text-blue-400' : 'text-slate-400'}" data-pos="${pos}">
                                        <div class="w-10 h-12 border border-slate-500 bg-slate-800 relative shadow-sm">
                                            <div class="absolute w-2 h-2 bg-current rounded-full ${
                                                pos === 'tl' ? 'top-1.5 left-1.5' : 
                                                pos === 'tc' ? 'top-1.5 left-1/2 -translate-x-1/2' :
                                                pos === 'tr' ? 'top-1.5 right-1.5' :
                                                pos === 'bl' ? 'bottom-1.5 left-1.5' :
                                                pos === 'bc' ? 'bottom-1.5 left-1/2 -translate-x-1/2' :
                                                'bottom-1.5 right-1.5'
                                            }"></div>
                                        </div>
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                        <div class="space-y-6">
                            <div>
                                <label class="block text-base font-bold text-slate-300 mb-3">文字サイズ</label>
                                <select id="num-size" class="w-full bg-slate-900 border border-slate-600 rounded-xl p-3 text-base text-slate-200 focus:border-blue-500 outline-none">
                                    <option value="8">小 (8pt)</option>
                                    <option value="10">やや小 (10pt)</option>
                                    <option value="12" selected>標準 (12pt)</option>
                                    <option value="14">やや大 (14pt)</option>
                                    <option value="18">大 (18pt)</option>
                                    <option value="24">特大 (24pt)</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-base font-bold text-slate-300 mb-3">書式</label>
                                <select id="num-format" class="w-full bg-slate-900 border border-slate-600 rounded-xl p-3 text-base text-slate-200 focus:border-blue-500 outline-none">
                                    <option value="fraction" selected>1 / 10 (ページ / 総数)</option>
                                    <option value="simple">1 (ページ番号のみ)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <button onclick="processNumber()" class="w-full bg-blue-600 text-white py-4 rounded-xl text-lg font-bold hover:bg-blue-500 transition-colors shadow-lg shadow-blue-900/20">
                        番号を追加してダウンロード
                    </button>
                </div>
            `;
        }

        let selectedPos = 'bc';
        function setNumberPos(pos) {
            selectedPos = pos;
            document.querySelectorAll('.number-pos-btn').forEach(btn => {
                if(btn.dataset.pos === pos) {
                    btn.classList.add('bg-blue-900/30', 'border-blue-500', 'text-blue-400');
                    btn.classList.remove('text-slate-400');
                } else {
                    btn.classList.remove('bg-blue-900/30', 'border-blue-500', 'text-blue-400');
                    btn.classList.add('text-slate-400');
                }
            });
        }

        // --- Logic: Switch Convert Mode ---
        function switchConvertMode(mode) {
            appState.convert.mode = mode;
            if (mode === 'img2pdf') appState.convert.images = [];
            else appState.convert.pdfFiles = [];
            renderContent();
        }

        // --- Logic: Reset ---
        function resetCurrentTab() {
            const tab = appState.currentTab;
            if (tab === 'compress') {
                appState.compress.files = [];
                appState.compress.isProcessing = false;
            } else if (tab === 'split') {
                appState.split.files = [];
                appState.split.pdfDoc = null;
                appState.split.splitPoint = 0;
                appState.split.visualsGenerated = false;
            } else if (tab === 'merge') {
                appState.merge.files = [];
            } else if (tab === 'organize') {
                appState.organize.files = [];
                appState.organize.pdfDoc = null;
                appState.organize.pageStates = [];
                appState.organize.visualsGenerated = false;
            } else if (tab === 'convert') {
                if (appState.convert.mode === 'img2pdf') appState.convert.images = [];
                else appState.convert.pdfFiles = [];
            } else if (tab === 'number') {
                appState.number.files = [];
            }
            renderContent();
        }


        // --- Event Handling ---

        function setupDragAndDrop() {
            const setup = (id, handlerType) => {
                const dropZone = document.getElementById(id + '-drop');
                const input = document.getElementById(id + '-input');
                
                if(!dropZone || !input) return;

                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    dropZone.addEventListener(eventName, preventDefaults, false);
                });

                function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }

                ['dragenter', 'dragover'].forEach(eventName => {
                    dropZone.addEventListener(eventName, () => dropZone.classList.add('active'), false);
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    dropZone.addEventListener(eventName, () => dropZone.classList.remove('active'), false);
                });

                dropZone.addEventListener('drop', (e) => {
                    const dt = e.dataTransfer;
                    const files = dt.files;
                    handleFiles(files, handlerType);
                });

                input.addEventListener('change', (e) => {
                    handleFiles(e.target.files, handlerType);
                    e.target.value = ''; // Reset input
                });
            };

            const tab = appState.currentTab;
            if(tab === 'compress') setup('compress', 'single');
            if(tab === 'split') setup('split', 'single');
            if(tab === 'merge') setup('merge-upload', 'multi');
            if(tab === 'organize') setup('organize', 'single'); 
            if(tab === 'convert') {
                if(appState.convert.mode === 'img2pdf') setup('img', 'img');
                else setup('pdf2img', 'single');
            }
            if(tab === 'number') setup('number', 'single');
        }

        // --- MERGE DRAG & DROP LOGIC ---
        function setupMergeDragAndDrop() {
            const items = document.querySelectorAll('.draggable-item');
            const container = document.getElementById('merge-list-container');

            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', item.dataset.index);
                    item.classList.add('dragging');
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                });
            });

            if (container) {
                container.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const afterElement = getDragAfterElement(container, e.clientY);
                    const draggable = document.querySelector('.dragging');
                    if (afterElement == null) {
                    } else {
                    }
                });

                container.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const draggable = document.querySelector('.dragging');
                    const afterElement = getDragAfterElement(container, e.clientY);
                    
                    const item = appState.merge.files.splice(fromIndex, 1)[0];
                    
                    let targetIndex;
                    if (afterElement) {
                        targetIndex = parseInt(afterElement.dataset.index);
                        if (fromIndex < targetIndex) targetIndex--; 
                    } else {
                        targetIndex = appState.merge.files.length;
                    }
                    
                    appState.merge.files.splice(targetIndex, 0, item);
                    renderContent();
                });
            }
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.draggable-item:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // --- File Handling ---

        function handleFiles(files, type) {
            if(type === 'img') {
                Array.from(files).forEach(file => {
                    if(!file.type.startsWith('image/')) return;
                    const url = URL.createObjectURL(file);
                    appState.convert.images.push({ file, url });
                });
                renderContent();
                return;
            }
            
            const pdfFiles = Array.from(files).filter(f => f.type === 'application/pdf');
            if(pdfFiles.length === 0) return;

            const tab = appState.currentTab;

            // Handle "Compress" Auto-Trigger
            if (tab === 'compress') {
                appState.compress.files = [pdfFiles[0]];
                appState.compress.isProcessing = true;
                renderContent(); // Show spinner
                setTimeout(() => processCompress(pdfFiles[0]), 500); 
                return;
            }

            if (type === 'single' || type === 'organize') {
                if (tab === 'split') {
                    appState.split.files = [pdfFiles[0]];
                    appState.split.visualsGenerated = false;
                    renderContent(); 
                } else if (tab === 'organize') {
                    appState.organize.files = [pdfFiles[0]];
                    appState.organize.visualsGenerated = false;
                    renderContent();
                } else if (tab === 'convert') {
                    appState.convert.pdfFiles = [pdfFiles[0]];
                    renderContent();
                } else if (tab === 'number') {
                    appState.number.files = [pdfFiles[0]];
                    renderContent();
                }
            } else if (type === 'multi') {
                if (tab === 'merge') {
                    appState.merge.files = [...appState.merge.files, ...pdfFiles];
                    renderContent();
                }
            }
        }

        function handleFileSelect(event, type) {
            handleFiles(event.target.files, type === 'img2pdf' ? 'img' : 'multi');
        }

        function removeImage(index) {
            appState.convert.images.splice(index, 1);
            renderContent();
        }

        function removeFileMerge(index) {
            appState.merge.files.splice(index, 1);
            renderContent();
        }

        function moveFileMerge(index, direction) {
            if (index + direction < 0 || index + direction >= appState.merge.files.length) return;
            const temp = appState.merge.files[index];
            appState.merge.files[index] = appState.merge.files[index + direction];
            appState.merge.files[index + direction] = temp;
            renderContent();
        }

        // --- FILENAME HELPER ---
        function getBaseName(filename) {
            return filename.replace(/\.[^/.]+$/, "");
        }

        // --- Logic: Compress ---
        async function processCompress(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
                const pdf = await loadingTask.promise;
                const newPdfDoc = await PDFDocument.create();

                const totalPages = pdf.numPages;
                
                for (let i = 1; i <= totalPages; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({scale: 1.5}); 
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({canvasContext: context, viewport: viewport}).promise;

                    const imgDataUrl = canvas.toDataURL('image/jpeg', 0.7);
                    const imgBytes = await fetch(imgDataUrl).then(res => res.arrayBuffer());
                    
                    const jpgImage = await newPdfDoc.embedJpg(imgBytes);
                    const newPage = newPdfDoc.addPage([jpgImage.width, jpgImage.height]);
                    newPage.drawImage(jpgImage, {
                        x: 0,
                        y: 0,
                        width: jpgImage.width,
                        height: jpgImage.height,
                    });
                }

                const pdfBytes = await newPdfDoc.save();
                const baseName = getBaseName(file.name);
                download(pdfBytes, `${baseName}_compressed.pdf`, "application/pdf");
                
                setTimeout(() => {
                    appState.compress.isProcessing = false;
                    appState.compress.files = []; 
                    renderContent();
                }, 1000);

            } catch (e) {
                console.error(e);
                alert('圧縮中にエラーが発生しました: ' + e.message);
                appState.compress.isProcessing = false;
                renderContent();
            }
        }


        // --- Logic: Split ---
        
        async function loadSplitPreview(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                appState.split.pdfDoc = await PDFDocument.load(arrayBuffer); 
                const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
                const pdf = await loadingTask.promise; 
                
                appState.split.visualsGenerated = true;

                const grid = document.getElementById('split-grid');
                if(!grid) return;
                grid.innerHTML = '';

                for(let i=1; i<=pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({scale: 0.5});
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    await page.render({canvasContext: context, viewport: viewport}).promise;

                    const div = document.createElement('div');
                    div.className = 'split-thumbnail rounded-lg overflow-hidden border-4 border-transparent bg-white';
                    div.innerHTML = `
                        <div class="aspect-[${viewport.width}/${viewport.height}] relative">
                             <img src="${canvas.toDataURL()}" class="w-full h-full object-contain">
                        </div>
                        <div class="text-center text-xs py-2 text-slate-400 border-t border-slate-700 bg-slate-800 font-medium">P.${i}</div>
                    `;
                    div.onclick = () => setSplitPoint(i, pdf.numPages);
                    div.id = `split-page-${i}`;
                    grid.appendChild(div);
                }
                updateSplitVisuals(pdf.numPages);
            } catch(e) {
                console.error(e);
                alert('プレビューの生成に失敗しました');
            }
        }

        function setSplitPoint(pageInfo, total) {
            appState.split.splitPoint = pageInfo;
            updateSplitVisuals(total);
        }

        function updateSplitVisuals(total) {
             for(let i=1; i<=total; i++) {
                 const el = document.getElementById(`split-page-${i}`);
                 if(!el) continue;
                 
                 el.className = 'split-thumbnail rounded-lg overflow-hidden border-4 bg-white'; 
                 
                 if(appState.split.splitPoint > 0) {
                     if(i <= appState.split.splitPoint) {
                         el.classList.add('split-part-1');
                         if(i === appState.split.splitPoint) el.classList.add('split-point');
                     } else {
                         el.classList.add('split-part-2');
                     }
                 } else {
                     el.classList.add('border-transparent');
                 }
             }
        }

        async function processSplit(mode) {
            if(!appState.split.files.length) return;
            setLoading(true);
            try {
                const file = appState.split.files[0];
                const baseName = getBaseName(file.name);
                const pdfDoc = appState.split.pdfDoc;
                const pageCount = pdfDoc.getPageCount();

                if (mode === 'all') {
                    const zip = new JSZip();
                    for (let i = 0; i < pageCount; i++) {
                        const newPdf = await PDFDocument.create();
                        const [copiedPage] = await newPdf.copyPages(pdfDoc, [i]);
                        newPdf.addPage(copiedPage);
                        const pdfBytes = await newPdf.save();
                        zip.file(`${baseName}_p${i + 1}.pdf`, pdfBytes);
                    }
                    const content = await zip.generateAsync({type:"blob"});
                    saveAs(content, `${baseName}_split_all.zip`);

                } else {
                    const splitP = appState.split.splitPoint;
                    if (splitP < 1 || splitP >= pageCount) {
                        alert('分割するページを選択してください（最終ページは選択できません）');
                        setLoading(false);
                        return;
                    }

                    const zip = new JSZip();

                    // Part 1
                    const pdf1 = await PDFDocument.create();
                    const pages1 = await pdf1.copyPages(pdfDoc, Array.from({length: splitP}, (_, i) => i));
                    pages1.forEach(p => pdf1.addPage(p));
                    zip.file(`${baseName}_part1.pdf`, await pdf1.save());
                    
                    // Part 2
                    const pdf2 = await PDFDocument.create();
                    const pages2 = await pdf2.copyPages(pdfDoc, Array.from({length: pageCount - splitP}, (_, i) => i + splitP));
                    pages2.forEach(p => pdf2.addPage(p));
                    zip.file(`${baseName}_part2.pdf`, await pdf2.save());

                    const content = await zip.generateAsync({type:"blob"});
                    saveAs(content, `${baseName}_split_at_p${splitP}.zip`);
                }
            } catch (e) {
                console.error(e);
                alert('エラーが発生しました: ' + e.message);
            }
            setLoading(false);
        }

        // --- Logic: Merge ---

        async function processMerge() {
            if(appState.merge.files.length < 2) return;
            setLoading(true);
            try {
                const mergedPdf = await PDFDocument.create();
                for (const file of appState.merge.files) {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await PDFDocument.load(arrayBuffer);
                    const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
                    copiedPages.forEach((page) => mergedPdf.addPage(page));
                }
                const pdfBytes = await mergedPdf.save();
                
                const firstFileName = appState.merge.files[0].name;
                const baseName = getBaseName(firstFileName);
                
                download(pdfBytes, `${baseName}_merged.pdf`, "application/pdf");
            } catch(e) {
                alert('結合中にエラーが発生しました。');
                console.error(e);
            }
            setLoading(false);
        }

        // --- Logic: Organize ---

        async function loadOrganizePreview(file, isReload = false) {
            try {
                let arrayBuffer;
                if(!isReload) {
                     arrayBuffer = await file.arrayBuffer();
                     appState.organize.pdfDoc = await PDFDocument.load(arrayBuffer);
                     appState.organize.visualsGenerated = true;
                } else {
                     arrayBuffer = await file.arrayBuffer();
                }
                
                const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
                const pdf = await loadingTask.promise;
                const pageCount = pdf.numPages;
                
                if(!isReload) appState.organize.pageStates = new Array(pageCount).fill(false);

                const grid = document.getElementById('organize-grid');
                if(grid) grid.innerHTML = '';

                for(let i=1; i<=pageCount; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({scale: 0.5});
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    await page.render({canvasContext: context, viewport: viewport}).promise;

                    const div = document.createElement('div');
                    const isDeleted = appState.organize.pageStates[i-1];
                    const extraClass = isDeleted ? 'selected ring-4 ring-red-500' : '';
                    
                    div.className = `page-thumbnail cursor-pointer relative rounded-lg overflow-hidden border border-slate-700 bg-white ${extraClass}`;
                    div.innerHTML = `
                        <div class="aspect-[${viewport.width}/${viewport.height}] relative">
                             <img src="${canvas.toDataURL()}" class="w-full h-full object-contain">
                             <div class="overlay absolute inset-0 bg-red-500/20 hidden"></div>
                        </div>
                        <div class="text-center text-xs py-2 text-slate-400 border-t border-slate-700 bg-slate-800 font-medium">P.${i}</div>
                    `;
                    
                    div.onclick = () => togglePage(i-1, div);
                    div.dataset.idx = i-1;
                    if(grid) grid.appendChild(div);
                }

            } catch(e) {
                console.error(e);
                alert('プレビューの生成に失敗しました');
                resetCurrentTab();
            }
        }

        function togglePage(idx, el) {
            appState.organize.pageStates[idx] = !appState.organize.pageStates[idx];
            if(appState.organize.pageStates[idx]) {
                el.classList.add('selected', 'ring-4', 'ring-red-500');
            } else {
                el.classList.remove('selected', 'ring-4', 'ring-red-500');
            }
        }

        function toggleAllOrganize(deleteMode) {
            const els = document.querySelectorAll('.page-thumbnail');
            els.forEach(el => {
                const idx = parseInt(el.dataset.idx);
                if(deleteMode) {
                    if(!appState.organize.pageStates[idx]) togglePage(idx, el);
                } else {
                    if(appState.organize.pageStates[idx]) togglePage(idx, el);
                }
            });
        }

        async function processOrganize() {
            if(!appState.organize.pdfDoc) return;
            setLoading(true);
            try {
                const newPdf = await PDFDocument.create();
                const keepIndices = appState.organize.pageStates.map((isDeleted, i) => isDeleted ? -1 : i).filter(i => i !== -1);
                
                if(keepIndices.length === 0) {
                    alert('少なくとも1ページは残してください');
                    setLoading(false);
                    return;
                }

                const pages = await newPdf.copyPages(appState.organize.pdfDoc, keepIndices);
                pages.forEach(p => newPdf.addPage(p));
                const pdfBytes = await newPdf.save();
                
                const baseName = getBaseName(appState.organize.files[0].name);
                download(pdfBytes, `${baseName}_organized.pdf`, "application/pdf");
            } catch(e) {
                alert('保存中にエラーが発生しました');
            }
            setLoading(false);
        }

        // --- Logic: Convert ---

        async function processImgToPdf() {
            if(appState.convert.images.length === 0) return;
            setLoading(true);
            try {
                const pdfDoc = await PDFDocument.create();
                
                for(const imgData of appState.convert.images) {
                    const buffer = await imgData.file.arrayBuffer();
                    let image;
                    if(imgData.file.type === 'image/jpeg') {
                        image = await pdfDoc.embedJpg(buffer);
                    } else {
                        image = await pdfDoc.embedPng(buffer);
                    }
                    
                    const page = pdfDoc.addPage([image.width, image.height]);
                    page.drawImage(image, {
                        x: 0,
                        y: 0,
                        width: image.width,
                        height: image.height,
                    });
                }
                
                const pdfBytes = await pdfDoc.save();
                const baseName = getBaseName(appState.convert.images[0].file.name);
                download(pdfBytes, `${baseName}_converted.pdf`, "application/pdf");

            } catch(e) {
                alert('変換に失敗しました');
                console.error(e);
            }
            setLoading(false);
        }

        async function processPdfToImg() {
             if(appState.convert.pdfFiles.length === 0) return;
             setLoading(true);
             try {
                const file = appState.convert.pdfFiles[0];
                const arrayBuffer = await file.arrayBuffer();
                const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
                const pdf = await loadingTask.promise;
                const zip = new JSZip();
                
                const baseName = getBaseName(file.name);

                for(let i=1; i<=pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({scale: 2.0}); // High res
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    await page.render({canvasContext: context, viewport: viewport}).promise;
                    
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    zip.file(`${baseName}_p${i}.png`, blob);
                }
                
                const content = await zip.generateAsync({type:"blob"});
                saveAs(content, `${baseName}_images.zip`);

             } catch(e) {
                 alert('変換に失敗しました');
             }
             setLoading(false);
        }


        // --- Logic: Numbering ---

        async function processNumber() {
            if(appState.number.files.length === 0) return;
            setLoading(true);
            try {
                const file = appState.number.files[0];
                const arrayBuffer = await file.arrayBuffer();
                const pdfDoc = await PDFDocument.load(arrayBuffer);
                const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
                const pages = pdfDoc.getPages();
                const total = pages.length;
                
                const size = parseInt(document.getElementById('num-size').value);
                const format = document.getElementById('num-format').value;

                pages.forEach((page, idx) => {
                    const { width, height } = page.getSize();
                    const num = idx + 1;
                    const text = format === 'simple' ? `${num}` : `${num} / ${total}`;
                    const textWidth = font.widthOfTextAtSize(text, size);
                    
                    let x, y;
                    const margin = 20;
                    
                    if(selectedPos.includes('l')) x = margin;
                    else if(selectedPos.includes('r')) x = width - textWidth - margin;
                    else x = (width - textWidth) / 2;

                    if(selectedPos.includes('t')) y = height - size - margin;
                    else y = margin;

                    page.drawText(text, {
                        x,
                        y,
                        size,
                        font,
                        color: rgb(0, 0, 0),
                    });
                });

                const pdfBytes = await pdfDoc.save();
                const baseName = getBaseName(file.name);
                download(pdfBytes, `${baseName}_numbered.pdf`, "application/pdf");

            } catch(e) {
                alert('処理に失敗しました');
                console.error(e);
            }
            setLoading(false);
        }

        // --- Helper: Loading Indicator ---
        function setLoading(isLoading) {
            const btn = document.querySelector('button[onclick^="process"]');
            if(btn) {
                if(isLoading) {
                    btn.dataset.originalText = btn.innerHTML;
                    btn.disabled = true;
                    btn.innerHTML = `<div class="loader w-5 h-5 border-2 border-white/30 border-t-white mr-2"></div> 処理中...`;
                    btn.classList.add('opacity-75', 'cursor-not-allowed');
                } else {
                    btn.innerHTML = btn.dataset.originalText || '完了';
                    btn.disabled = false;
                    btn.classList.remove('opacity-75', 'cursor-not-allowed');
                }
            }
        }

        // Initialize Icons
        lucide.createIcons();
        renderTabs();
        renderContent();

    </script>
</body>
</html>
